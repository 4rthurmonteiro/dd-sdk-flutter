// Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2019-2022 Datadog, Inc.

import 'dart:io';

import 'package:collection/collection.dart';

import 'issue_reporter.dart';
import 'monitor_configuration.dart';

class TerraformRenderer {
  final String mainTemplate;
  final MonitorTemplate logsTemplate;
  final MonitorTemplate apmTemplate;
  final MonitorTemplate rumTemplate;

  TerraformRenderer(
    this.mainTemplate, {
    required this.logsTemplate,
    required this.apmTemplate,
    required this.rumTemplate,
  });

  String render(String outputPath, List<MonitorConfiguration> monitors,
      IssueReporter issueReporter) {
    final buffer = StringBuffer();
    buffer.writeln('# This file is auto-generated by e2e_generator.dart');
    buffer.writeln('# Do not edit it directly');
    buffer.writeln();

    buffer.writeln(mainTemplate);

    buffer.writeln('# Monitors:\n');
    for (final monitor in monitors) {
      MonitorTemplate template;
      switch (monitor.type) {
        case MonitorType.logs:
          template = logsTemplate;
          break;
        case MonitorType.apm:
          template = apmTemplate;
          break;
        case MonitorType.rum:
          template = rumTemplate;
          break;
      }

      buffer.writeln(template.render(monitor, issueReporter));
    }

    return buffer.toString();
  }

  static Future<TerraformRenderer?> fromFiles(
    String mainPath,
    String logsPath,
    String apmPath,
    String rumPath,
  ) async {
    final mainSource = await File(mainPath).readAsString();
    final logsSource = await File(logsPath).readAsString();
    final apmSource = await File(apmPath).readAsString();
    final rumSource = await File(rumPath).readAsString();

    return TerraformRenderer(
      mainSource,
      logsTemplate: MonitorTemplate(logsSource),
      apmTemplate: MonitorTemplate(apmSource),
      rumTemplate: MonitorTemplate(rumSource),
    );
  }

  static Future<TerraformRenderer?> fromTemplatePath(
      String templatePath) async {
    return TerraformRenderer.fromFiles(
        '$templatePath/main.tf.src',
        '$templatePath/monitor-logs.tf.src',
        '$templatePath/monitor-apm.tf.src',
        '$templatePath/monitor-rum.tf.src');
  }
}

class MonitorTemplate {
  final String template;

  MonitorTemplate(this.template);

  String render(
      MonitorConfiguration configuration, IssueReporter issueReporter) {
    final variableRegex = RegExp(
        r'\${{(?<variableName>[a-zA-Z0-9_]+)(\:-(?<defaultValue>.+))?}}');

    var renderedUserVariables = <String>[];

    var renderedLines = StringBuffer();
    template.split('\n').forEachIndexed((i, line) {
      var renderedLine = line;

      final matches = variableRegex.allMatches(line);
      for (final match in matches) {
        var variableName = match.namedGroup('variableName');
        var defaultValue = match.namedGroup('defaultValue');

        var userVariable = configuration.variables
            .firstWhereOrNull((e) => e.name == variableName);
        if (userVariable != null) {
          renderedLine = renderedLine.replaceRange(
              match.start, match.end, userVariable.value);
          renderedUserVariables.add(userVariable.name);
        } else if (defaultValue != null) {
          renderedLine =
              renderedLine.replaceRange(match.start, match.end, defaultValue);
        } else {
          issueReporter(IssueSeverity.error, configuration.codeReference,
              'Variable `$variableName` is required but not defined for this monitor');
        }
      }

      renderedLines.writeln(renderedLine);
    });

    configuration.variables
        .where((e) => !renderedUserVariables.contains(e.name))
        .forEach((e) {
      issueReporter(IssueSeverity.warning, configuration.codeReference,
          'Variable `${e.name} defined in monitor was not used');
    });

    return renderedLines.toString();
  }
}
