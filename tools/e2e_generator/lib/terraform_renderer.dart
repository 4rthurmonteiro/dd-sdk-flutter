// Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2019-2022 Datadog, Inc.

import 'dart:io';

import 'package:collection/collection.dart';

import 'issue_reporter.dart';
import 'monitor_configuration.dart';

class TerraformRenderer {
  final String mainTemplate;
  final MonitorTemplate logsTemplate;
  final MonitorTemplate apmTemplate;
  final MonitorTemplate rumTemplate;

  TerraformRenderer(
    this.mainTemplate, {
    required this.logsTemplate,
    required this.apmTemplate,
    required this.rumTemplate,
  });

  String render(String outputPath, List<MonitorGroup> groups,
      IssueReporter issueReporter) {
    final buffer = StringBuffer();
    buffer.writeln('# This file is auto-generated by e2e_generator.dart');
    buffer.writeln('# Do not edit it directly');
    buffer.writeln();

    buffer.writeln(mainTemplate);

    buffer.writeln('# Monitors:\n');
    for (final group in groups) {
      for (final monitor in group.monitors) {
        MonitorTemplate template;
        switch (monitor.type) {
          case MonitorType.logs:
            template = logsTemplate;
            break;
          case MonitorType.apm:
            template = apmTemplate;
            break;
          case MonitorType.rum:
            template = rumTemplate;
            break;
          case MonitorType.global:
            issueReporter.report(IssueSeverity.warning,
                'Attempting to render global monitor template. This is a bug in the generator script');
            continue;
        }

        buffer
            .writeln(template.render(monitor, group.variables, issueReporter));
      }
    }

    return buffer.toString();
  }

  static Future<TerraformRenderer?> fromFiles(
    String mainPath,
    String logsPath,
    String apmPath,
    String rumPath,
  ) async {
    final mainSource = await File(mainPath).readAsString();
    final logsSource = await File(logsPath).readAsString();
    final apmSource = await File(apmPath).readAsString();
    final rumSource = await File(rumPath).readAsString();

    return TerraformRenderer(
      mainSource,
      logsTemplate: MonitorTemplate(logsSource),
      apmTemplate: MonitorTemplate(apmSource),
      rumTemplate: MonitorTemplate(rumSource),
    );
  }

  static Future<TerraformRenderer?> fromTemplatePath(
      String templatePath) async {
    return TerraformRenderer.fromFiles(
        '$templatePath/main.tf.src',
        '$templatePath/monitor-logs.tf.src',
        '$templatePath/monitor-apm.tf.src',
        '$templatePath/monitor-rum.tf.src');
  }
}

class MonitorTemplate {
  final String template;

  MonitorTemplate(this.template);

  String render(
    MonitorConfiguration configuration,
    List<MonitorVariable> globalVars,
    IssueReporter issueReporter,
  ) {
    issueReporter.pushReference(configuration.codeReference);

    if (configuration.variants.isEmpty) {
      return _renderVariant(configuration, globalVars, issueReporter);
    }

    var renderedLines = StringBuffer();

    for (final variant in configuration.variants) {
      renderedLines.writeln(_renderVariant(
          configuration,
          [
            MonitorVariable(name: 'variant', value: variant),
            ...globalVars,
          ],
          issueReporter));
    }

    issueReporter.popReference();

    return renderedLines.toString();
  }

  String _renderVariant(MonitorConfiguration configuration,
      List<MonitorVariable> globalVars, IssueReporter issueReporter) {
    final renderedLines = StringBuffer();

    var renderedUserVariables = <String>[];

    var variables = [...globalVars, ...configuration.variables];

    template.split('\n').forEachIndexed((i, line) {
      var renderedLine = _replaceVariables(
          line, variables, renderedUserVariables, issueReporter);

      renderedLine = renderedLine.replaceAll(
          '## MONITOR_CODE ##', configuration.codeReference.code);

      renderedLines.writeln(renderedLine);
    });

    configuration.variables
        .where((e) => !renderedUserVariables.contains(e.name))
        .forEach((e) {
      issueReporter.report(IssueSeverity.warning,
          'Variable `${e.name} defined in monitor was not used');
    });

    return renderedLines.toString();
  }

  String _replaceVariables(
    String line,
    List<MonitorVariable> variables,
    List<String> renderedVariables,
    IssueReporter issueReporter,
  ) {
    final variableRegex = RegExp(
        r'\${{(?<variableName>[a-zA-Z0-9_]+)(\:-(?<defaultValue>.*?))?}}');

    var renderedLine = line;
    while (variableRegex.hasMatch(renderedLine)) {
      var match = variableRegex.firstMatch(renderedLine)!;

      var variableName = match.namedGroup('variableName');
      var defaultValue = match.namedGroup('defaultValue');

      var userVariable =
          variables.firstWhereOrNull((e) => e.name == variableName);
      if (userVariable != null) {
        renderedLine = renderedLine.replaceRange(
            match.start, match.end, userVariable.value);
        renderedVariables.add(userVariable.name);
      } else if (defaultValue != null) {
        renderedLine =
            renderedLine.replaceRange(match.start, match.end, defaultValue);
      } else {
        issueReporter.report(IssueSeverity.error,
            'Variable `$variableName` is required but not defined for this monitor');
        renderedLine =
            renderedLine.replaceRange(match.start, match.end, '??UNDEFINED??');
      }
    }
    return renderedLine;
  }
}
